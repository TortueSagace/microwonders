  // Placeholder for initializing reg1 and reg2 with values
    // Actual initialization should be done as per the specific requirements or context
    MOVI 1, 20000 // Initialize reg3 (result LSB) to 0
    MOVI 2, 4	 	
    // Initialize result registers to 0
    ADDI 3, 3, 0  // Initialize reg3 (result LSB) to 0
    ADDI 4, 4, 0  // Initialize reg4 (result MSB) to 0, assuming we manage overflow
 
    // Initialize loop counter (assuming 16-bit multiplication, thus 16 iterations)
    ADDI 5, 0, 16  // reg5 is the loop counter, initialized to 16
 
multiply_loop: SHIFTI 6, 2, -1 
    SHIFTI 6, 6, 15  // Arithmetic shift right by 15, moving MSB to LSB, preserving sign
 
    // If LSB was 1, add reg1 to the result (reg3)
    BEQ 6, 0, skip // If reg6 is 0 (LSB of reg2 was 0), skip addition
    ADD 3, 3, reg1      // Add reg1 to reg3 (result)
 
    // Shift reg1 left by 1 (double it) for the next bit in reg2
    SHIFTI 1, 1, 1
 
    // Prepare for the next iteration
    SHIFTI 2, 2, -1  // Logical shift reg2 right by 1
 
    // Decrement loop counter and loop if not done
    ADDI 5, 5, -1
    BEQ 5, 0, end_multiply  // If reg5 is 0, multiplication is done
    BEQ 0, 0, multiply_loop // Unconditional jump to next loop iteration
 
skip: BEQ 0, 0, continue_loop  // Jump to continue loop if addition was skipped
 
continue_loop: ADDI 5, 5, -1
    BEQ 5, 0, end_multiply  // Check if loop is done
    BEQ 0, 0, multiply_loop // Unconditional jump to next loop iteration
 
end_multiply: halt
